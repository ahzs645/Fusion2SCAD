#Author: Fusion2SCAD
#Description: Export Fusion 360 parametric designs to OpenSCAD with BOSL2 support

import adsk.core, adsk.fusion, traceback
import os
import math
import sys
import json

# Add current directory to path for local imports
script_dir = os.path.dirname(os.path.realpath(__file__))
if script_dir not in sys.path:
    sys.path.append(script_dir)

try:
    from profile_utils import (
        extract_profile_polygon,
        detect_shape_type,
        generate_bosl2_shape,
        format_polygon_scad,
        format_polygon_with_holes_scad
    )
    PROFILE_UTILS_AVAILABLE = True
except ImportError:
    PROFILE_UTILS_AVAILABLE = False

# Global app references
app = adsk.core.Application.get()
ui = app.userInterface

# Conversion factor: Fusion 360 uses cm internally, OpenSCAD typically uses mm
CM_TO_MM = 10.0

class SCADExporter:
    """Main exporter class that converts Fusion 360 design to OpenSCAD/BOSL2 code"""

    def __init__(self, design: adsk.fusion.Design):
        self.design = design
        self.parameters = {}
        self.scad_lines = []
        self.indent_level = 0
        self.processed_bodies = set()
        self.feature_map = {}  # Maps Fusion features to SCAD operations
        self.body_to_feature = {}  # Maps body tokens to their creating feature
        self.feature_modifiers = {}  # Maps feature to fillet/chamfer modifiers

    def indent(self):
        return "    " * self.indent_level

    def add_line(self, line: str):
        self.scad_lines.append(f"{self.indent()}{line}")

    def add_blank(self):
        self.scad_lines.append("")

    def extract_parameters(self):
        """Extract all user-defined parameters from the design"""
        params = self.design.userParameters
        for i in range(params.count):
            param = params.item(i)
            name = self._sanitize_name(param.name)
            # Convert to mm for OpenSCAD
            value = param.value * CM_TO_MM
            unit = param.unit
            comment = param.comment if param.comment else ""
            self.parameters[param.name] = {
                'name': name,
                'value': value,
                'unit': unit,
                'comment': comment,
                'expression': param.expression
            }
        return self.parameters

    def _sanitize_name(self, name: str) -> str:
        """Convert Fusion parameter name to valid OpenSCAD variable name"""
        # Replace spaces and special chars with underscores
        sanitized = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)
        # Ensure it doesn't start with a number
        if sanitized and sanitized[0].isdigit():
            sanitized = '_' + sanitized
        return sanitized.lower()

    def _format_value(self, value: float, precision: int = 4) -> str:
        """Format a numeric value for OpenSCAD output"""
        if abs(value - round(value)) < 0.0001:
            return str(int(round(value)))
        return f"{value:.{precision}f}".rstrip('0').rstrip('.')

    def _normal_to_rotation(self, nx: float, ny: float, nz: float) -> tuple:
        """Convert a normal vector to rotation angles (rx, ry, rz) in degrees.
        This rotates the Z-axis to align with the given normal."""
        # Calculate rotation to align Z-axis with the normal
        # Using spherical coordinates approach
        length = math.sqrt(nx*nx + ny*ny + nz*nz)
        if length < 0.0001:
            return (0, 0, 0)

        nx, ny, nz = nx/length, ny/length, nz/length

        # Rotation around Y-axis (pitch) to tilt Z toward X
        ry = math.degrees(math.asin(-nx))

        # Rotation around X-axis (roll) to tilt Z toward Y
        rx = math.degrees(math.atan2(ny, nz))

        return (rx, ry, 0)

    def _get_param_or_value(self, fusion_value: float, fusion_expression: str = None) -> str:
        """Return parameter name if it matches, otherwise return the numeric value"""
        value_mm = fusion_value * CM_TO_MM

        # Check if this value matches any parameter
        if fusion_expression:
            for orig_name, param_info in self.parameters.items():
                if orig_name in fusion_expression:
                    return param_info['name']

        return self._format_value(value_mm)

    def generate_header(self) -> list:
        """Generate the OpenSCAD file header with BOSL2 include"""
        lines = [
            "// Generated by Fusion2SCAD",
            "// https://github.com/BelfrySCAD/BOSL2",
            "",
            "include <BOSL2/std.scad>",
            "include <BOSL2/rounding.scad>",
            "",
            "// Set default fragment count for smooth curves",
            "$fn = 32;",
            "",
            "// ============================================",
            "// Parameters (exported from Fusion 360)",
            "// ============================================",
            ""
        ]
        return lines

    def generate_parameters_section(self) -> list:
        """Generate OpenSCAD variable declarations from Fusion parameters"""
        lines = []
        for orig_name, param_info in self.parameters.items():
            comment = f"  // {param_info['comment']}" if param_info['comment'] else ""
            lines.append(f"{param_info['name']} = {self._format_value(param_info['value'])};{comment}")
        if lines:
            lines.append("")
        return lines

    def extract_sketch_geometry(self, sketch: adsk.fusion.Sketch) -> dict:
        """Extract geometry from a Fusion 360 sketch"""
        geometry = {
            'lines': [],
            'circles': [],
            'arcs': [],
            'rectangles': [],
            'points': [],
            'profiles': []
        }

        # Extract sketch curves
        for curve in sketch.sketchCurves:
            if isinstance(curve, adsk.fusion.SketchLine):
                start = curve.startSketchPoint.geometry
                end = curve.endSketchPoint.geometry
                geometry['lines'].append({
                    'start': (start.x * CM_TO_MM, start.y * CM_TO_MM),
                    'end': (end.x * CM_TO_MM, end.y * CM_TO_MM)
                })
            elif isinstance(curve, adsk.fusion.SketchCircle):
                center = curve.centerSketchPoint.geometry
                geometry['circles'].append({
                    'center': (center.x * CM_TO_MM, center.y * CM_TO_MM),
                    'radius': curve.radius * CM_TO_MM
                })
            elif isinstance(curve, adsk.fusion.SketchArc):
                center = curve.centerSketchPoint.geometry
                geometry['arcs'].append({
                    'center': (center.x * CM_TO_MM, center.y * CM_TO_MM),
                    'radius': curve.radius * CM_TO_MM,
                    'start_angle': math.degrees(curve.startAngle),
                    'end_angle': math.degrees(curve.endAngle)
                })

        # Try to detect rectangles from sketch profiles
        for profile in sketch.profiles:
            loops = profile.profileLoops
            for loop in loops:
                curves = loop.profileCurves
                if len(curves) == 4:
                    # Check if it's a rectangle (4 lines, perpendicular)
                    all_lines = all(isinstance(c.sketchEntity, adsk.fusion.SketchLine) for c in curves)
                    if all_lines:
                        bbox = profile.boundingBox
                        min_pt = bbox.minPoint
                        max_pt = bbox.maxPoint
                        width = (max_pt.x - min_pt.x) * CM_TO_MM
                        height = (max_pt.y - min_pt.y) * CM_TO_MM
                        center_x = (min_pt.x + max_pt.x) / 2 * CM_TO_MM
                        center_y = (min_pt.y + max_pt.y) / 2 * CM_TO_MM
                        geometry['rectangles'].append({
                            'width': width,
                            'height': height,
                            'center': (center_x, center_y)
                        })

        return geometry

    def analyze_extrude_feature(self, feature: adsk.fusion.ExtrudeFeature) -> dict:
        """Analyze an extrude feature and determine best BOSL2 representation"""
        result = {
            'type': 'extrude',
            'operation': self._get_operation_type(feature.operation),
            'height': None,
            'profiles': [],
            'is_symmetric': False,
            'taper_angle': 0,
            'sketch_plane': 'XY',  # Default plane
            'plane_origin': (0, 0, 0),
            'plane_normal': (0, 0, 1),  # Default: Z-up
            'rotation': None  # Rotation needed to orient shape
        }

        # Get extrusion extent
        extent_def = feature.extentOne
        if isinstance(extent_def, adsk.fusion.DistanceExtentDefinition):
            result['height'] = extent_def.distance.value * CM_TO_MM

        # Check for symmetric extrusion
        if feature.extentTwo:
            result['is_symmetric'] = True

        # Get taper angle if present
        if feature.taperAngleOne:
            result['taper_angle'] = math.degrees(feature.taperAngleOne.value)

        # Get the sketch plane orientation and origin
        try:
            # Get the start face to determine extrusion direction
            start_faces = feature.startFaces
            if start_faces and start_faces.count > 0:
                start_face = start_faces.item(0)
                # Get the face normal at the center
                evaluator = start_face.geometry.evaluator if hasattr(start_face.geometry, 'evaluator') else None

            # Try to get sketch plane info from the profile's parent sketch
            profiles = feature.profile
            profile = profiles if isinstance(profiles, adsk.fusion.Profile) else profiles.item(0)
            sketch = profile.parentSketch

            if sketch:
                # Get the sketch plane
                sketch_plane = sketch.referencePlane
                origin = sketch.origin
                result['plane_origin'] = (
                    origin.x * CM_TO_MM,
                    origin.y * CM_TO_MM,
                    origin.z * CM_TO_MM
                )

                # Get sketch transform (3D orientation)
                transform = sketch.transform
                if transform:
                    # Extract the Z-axis (normal) from the transform matrix
                    # This tells us which direction the extrusion goes
                    z_axis = transform.getAsCoordinateSystem()[3]  # Get Z-axis direction
                    result['plane_normal'] = (z_axis.x, z_axis.y, z_axis.z)

                    # Determine the plane type for simpler cases
                    nx, ny, nz = z_axis.x, z_axis.y, z_axis.z
                    tolerance = 0.001

                    if abs(nz - 1) < tolerance or abs(nz + 1) < tolerance:
                        result['sketch_plane'] = 'XY'
                        result['rotation'] = None if nz > 0 else (180, 0, 0)
                    elif abs(ny - 1) < tolerance or abs(ny + 1) < tolerance:
                        result['sketch_plane'] = 'XZ'
                        result['rotation'] = (-90, 0, 0) if ny > 0 else (90, 0, 0)
                    elif abs(nx - 1) < tolerance or abs(nx + 1) < tolerance:
                        result['sketch_plane'] = 'YZ'
                        result['rotation'] = (0, 90, 0) if nx > 0 else (0, -90, 0)
                    else:
                        result['sketch_plane'] = 'CUSTOM'
                        # For custom planes, calculate rotation from normal
                        result['rotation'] = self._normal_to_rotation(nx, ny, nz)
        except Exception as e:
            # If we can't get plane info, assume XY plane
            pass

        # Analyze the profile to determine shape type
        # feature.profile can be a single Profile or an ObjectCollection
        profiles = feature.profile
        if isinstance(profiles, adsk.fusion.Profile):
            # Single profile
            profile_info = self._analyze_profile(profiles)
            result['profiles'].append(profile_info)
        else:
            # Collection of profiles
            try:
                for i in range(profiles.count):
                    profile = profiles.item(i)
                    if isinstance(profile, adsk.fusion.Profile):
                        profile_info = self._analyze_profile(profile)
                        result['profiles'].append(profile_info)
            except:
                # Fallback: try direct iteration
                try:
                    for profile in profiles:
                        if isinstance(profile, adsk.fusion.Profile):
                            profile_info = self._analyze_profile(profile)
                            result['profiles'].append(profile_info)
                except:
                    pass

        return result

    def _analyze_profile(self, profile: adsk.fusion.Profile) -> dict:
        """Analyze a sketch profile to determine its shape"""
        info = {
            'shape': 'polygon',  # Default
            'bbox': None,
            'center': None,
            'is_circle': False,
            'is_rectangle': False,
            'is_rounded_rect': False,
            'profile_obj': profile  # Store for later polygon extraction
        }

        bbox = profile.boundingBox
        min_pt = bbox.minPoint
        max_pt = bbox.maxPoint

        width = (max_pt.x - min_pt.x) * CM_TO_MM
        height = (max_pt.y - min_pt.y) * CM_TO_MM
        center_x = (min_pt.x + max_pt.x) / 2 * CM_TO_MM
        center_y = (min_pt.y + max_pt.y) / 2 * CM_TO_MM

        info['bbox'] = {'width': width, 'height': height}
        info['center'] = (center_x, center_y)

        # Check if it's a circle
        loops = profile.profileLoops
        if loops.count == 1:
            curves = loops.item(0).profileCurves
            if curves.count == 1:
                entity = curves.item(0).sketchEntity
                if isinstance(entity, adsk.fusion.SketchCircle):
                    info['is_circle'] = True
                    info['shape'] = 'circle'
                    info['radius'] = entity.radius * CM_TO_MM
            elif curves.count == 4:
                # Likely a rectangle
                all_lines = all(
                    isinstance(curves.item(i).sketchEntity, adsk.fusion.SketchLine)
                    for i in range(4)
                )
                if all_lines:
                    info['is_rectangle'] = True
                    info['shape'] = 'rectangle'

            elif curves.count == 8:
                # Possibly a rounded rectangle (4 lines + 4 arcs)
                lines = []
                arcs = []
                for i in range(curves.count):
                    entity = curves.item(i).sketchEntity
                    if isinstance(entity, adsk.fusion.SketchLine):
                        lines.append(entity)
                    elif isinstance(entity, adsk.fusion.SketchArc):
                        arcs.append(entity)

                if len(lines) == 4 and len(arcs) == 4:
                    # Check if all arcs have same radius
                    radii = [arc.radius * CM_TO_MM for arc in arcs]
                    if max(radii) - min(radii) < 0.01:
                        info['is_rounded_rect'] = True
                        info['shape'] = 'rounded_rect'
                        info['rounding'] = radii[0]

        return info

    def _get_operation_type(self, operation) -> str:
        """Convert Fusion operation type to OpenSCAD equivalent"""
        op_map = {
            adsk.fusion.FeatureOperations.NewBodyFeatureOperation: 'new',
            adsk.fusion.FeatureOperations.JoinFeatureOperation: 'union',
            adsk.fusion.FeatureOperations.CutFeatureOperation: 'difference',
            adsk.fusion.FeatureOperations.IntersectFeatureOperation: 'intersection'
        }
        return op_map.get(operation, 'union')

    def analyze_fillet_feature(self, feature: adsk.fusion.FilletFeature) -> dict:
        """Analyze a fillet feature and track which bodies it affects"""
        result = {
            'type': 'fillet',
            'radius': 0,
            'edges': [],
            'affected_bodies': set()
        }

        # Get fillet radius from the first edge set
        edge_sets = feature.edgeSets
        if edge_sets.count > 0:
            edge_set = edge_sets.item(0)
            if isinstance(edge_set, adsk.fusion.ConstantRadiusFilletEdgeSet):
                result['radius'] = edge_set.radius.value * CM_TO_MM
                # Track which edges/bodies this fillet affects
                try:
                    edges = edge_set.edges
                    for edge in edges:
                        body = edge.body
                        if body:
                            result['affected_bodies'].add(body.entityToken)
                except:
                    pass

        return result

    def analyze_chamfer_feature(self, feature: adsk.fusion.ChamferFeature) -> dict:
        """Analyze a chamfer feature and track which bodies it affects"""
        result = {
            'type': 'chamfer',
            'distance': 0,
            'affected_bodies': set()
        }

        # Get chamfer distance
        edge_sets = feature.edgeSets
        if edge_sets.count > 0:
            edge_set = edge_sets.item(0)
            if isinstance(edge_set, adsk.fusion.EqualDistanceChamferEdgeSet):
                result['distance'] = edge_set.distance.value * CM_TO_MM
                # Track which edges/bodies this chamfer affects
                try:
                    edges = edge_set.edges
                    for edge in edges:
                        body = edge.body
                        if body:
                            result['affected_bodies'].add(body.entityToken)
                except:
                    pass

        return result

    def analyze_revolve_feature(self, feature: adsk.fusion.RevolveFeature) -> dict:
        """Analyze a revolve feature"""
        result = {
            'type': 'revolve',
            'operation': self._get_operation_type(feature.operation),
            'angle': 360,  # Default full revolution
            'profiles': []
        }

        # Get revolution angle
        extent_def = feature.extentDefinition
        if isinstance(extent_def, adsk.fusion.AngleExtentDefinition):
            result['angle'] = math.degrees(extent_def.angle.value)

        # Analyze profiles (can be single Profile or ObjectCollection)
        profiles = feature.profile
        if isinstance(profiles, adsk.fusion.Profile):
            profile_info = self._analyze_profile(profiles)
            result['profiles'].append(profile_info)
        else:
            try:
                for i in range(profiles.count):
                    profile = profiles.item(i)
                    if isinstance(profile, adsk.fusion.Profile):
                        profile_info = self._analyze_profile(profile)
                        result['profiles'].append(profile_info)
            except:
                pass

        return result

    def _generate_transform_prefix(self, feature_info: dict, profile_center: tuple) -> list:
        """Generate translate/rotate prefix for proper 3D positioning"""
        lines = []
        indent = ""

        # Get plane origin and rotation
        plane_origin = feature_info.get('plane_origin', (0, 0, 0))
        rotation = feature_info.get('rotation')
        cx, cy = profile_center

        # Calculate full translation (plane origin + profile center in plane)
        ox, oy, oz = plane_origin

        # Apply rotation if needed (non-XY plane)
        if rotation and rotation != (0, 0, 0):
            rx, ry, rz = rotation
            # Translate to plane origin, then rotate, then translate in local coords
            if ox != 0 or oy != 0 or oz != 0:
                lines.append(f"translate([{self._format_value(ox)}, {self._format_value(oy)}, {self._format_value(oz)}])")
                indent = "    "
            lines.append(f"{indent}rotate([{self._format_value(rx)}, {self._format_value(ry)}, {self._format_value(rz)}])")
            indent += "    "
            if cx != 0 or cy != 0:
                lines.append(f"{indent}translate([{self._format_value(cx)}, {self._format_value(cy)}, 0])")
                indent += "    "
        else:
            # XY plane - just translate
            total_x = ox + cx
            total_y = oy + cy
            total_z = oz
            if total_x != 0 or total_y != 0 or total_z != 0:
                lines.append(f"translate([{self._format_value(total_x)}, {self._format_value(total_y)}, {self._format_value(total_z)}])")
                indent = "    "

        return lines, indent

    def generate_extrude_scad(self, feature_info: dict, feature_name: str,
                               rounding: float = None, chamfer: float = None) -> list:
        """Generate BOSL2 code for an extrusion with optional rounding/chamfer"""
        lines = []
        height = self._format_value(feature_info['height'])

        # Build modifier string for BOSL2
        modifiers = []
        if rounding and rounding > 0:
            modifiers.append(f"rounding={self._format_value(rounding)}")
        if chamfer and chamfer > 0:
            modifiers.append(f"chamfer={self._format_value(chamfer)}")
        modifier_str = ", ".join(modifiers)

        for profile in feature_info['profiles']:
            lines.append(f"// {feature_name} (plane: {feature_info.get('sketch_plane', 'XY')})")

            if profile['is_circle']:
                # Use BOSL2 cyl() for cylinder
                radius = self._format_value(profile['radius'])
                cx, cy = profile['center']

                # Build cyl() call with optional rounding
                cyl_params = [f"h={height}", f"r={radius}"]
                if rounding and rounding > 0:
                    cyl_params.append(f"rounding={self._format_value(rounding)}")
                if chamfer and chamfer > 0:
                    cyl_params.append(f"chamfer={self._format_value(chamfer)}")
                cyl_params.append("anchor=BOTTOM")
                cyl_call = f"cyl({', '.join(cyl_params)});"

                # Generate transform prefix
                transform_lines, indent = self._generate_transform_prefix(feature_info, (cx, cy))
                lines.extend(transform_lines)
                lines.append(f"{indent}{cyl_call}")

            elif profile.get('is_rounded_rect'):
                # Use BOSL2 cuboid() with rounding for rounded rectangle
                width = self._format_value(profile['bbox']['width'])
                depth = self._format_value(profile['bbox']['height'])
                sketch_rounding = self._format_value(profile['rounding'])
                cx, cy = profile['center']

                # Combine sketch rounding with fillet rounding
                cuboid_params = [f"[{width}, {depth}, {height}]"]
                cuboid_params.append(f"rounding={sketch_rounding}")
                if rounding and rounding > 0:
                    cuboid_params.append(f"edges=[\"Z\", TOP, BOTTOM]")
                else:
                    cuboid_params.append(f"edges=\"Z\"")
                if chamfer and chamfer > 0:
                    cuboid_params.append(f"chamfer={self._format_value(chamfer)}")
                cuboid_params.append("anchor=BOTTOM")
                cuboid_call = f"cuboid({', '.join(cuboid_params)});"

                # Generate transform prefix
                transform_lines, indent = self._generate_transform_prefix(feature_info, (cx, cy))
                lines.extend(transform_lines)
                lines.append(f"{indent}{cuboid_call}")

            elif profile['is_rectangle']:
                # Use BOSL2 cuboid() for box
                width = self._format_value(profile['bbox']['width'])
                depth = self._format_value(profile['bbox']['height'])
                cx, cy = profile['center']

                # Build cuboid() call with optional rounding/chamfer
                cuboid_params = [f"[{width}, {depth}, {height}]"]
                if rounding and rounding > 0:
                    cuboid_params.append(f"rounding={self._format_value(rounding)}")
                if chamfer and chamfer > 0:
                    cuboid_params.append(f"chamfer={self._format_value(chamfer)}")
                cuboid_params.append("anchor=BOTTOM")
                cuboid_call = f"cuboid({', '.join(cuboid_params)});"

                # Generate transform prefix
                transform_lines, indent = self._generate_transform_prefix(feature_info, (cx, cy))
                lines.extend(transform_lines)
                lines.append(f"{indent}{cuboid_call}")

            else:
                # Generic extrusion - use offset_sweep for rounding if available
                cx, cy = profile.get('center', (0, 0))
                transform_lines, indent = self._generate_transform_prefix(feature_info, (0, 0))  # Polygon coords already include position
                lines.extend(transform_lines)

                if PROFILE_UTILS_AVAILABLE and 'profile_obj' in profile:
                    try:
                        poly_data = extract_profile_polygon(profile['profile_obj'])
                        if poly_data['holes']:
                            polygon_code = format_polygon_with_holes_scad(
                                poly_data['outer'], poly_data['holes']
                            )
                        else:
                            polygon_code = format_polygon_scad(poly_data['outer'])

                        # Use offset_sweep for rounding on complex profiles
                        if rounding and rounding > 0:
                            lines.append(f"{indent}// Using BOSL2 offset_sweep for rounded extrusion")
                            lines.append(f"{indent}offset_sweep(")
                            for poly_line in polygon_code.split('\n'):
                                lines.append(f"{indent}    {poly_line},")
                            lines.append(f"{indent}    height={height},")
                            lines.append(f"{indent}    top=os_circle(r={self._format_value(rounding)}),")
                            lines.append(f"{indent}    bottom=os_circle(r={self._format_value(rounding)})")
                            lines.append(f"{indent});")
                        elif chamfer and chamfer > 0:
                            lines.append(f"{indent}// Using BOSL2 offset_sweep for chamfered extrusion")
                            lines.append(f"{indent}offset_sweep(")
                            for poly_line in polygon_code.split('\n'):
                                lines.append(f"{indent}    {poly_line},")
                            lines.append(f"{indent}    height={height},")
                            lines.append(f"{indent}    top=os_chamfer(height={self._format_value(chamfer)}),")
                            lines.append(f"{indent}    bottom=os_chamfer(height={self._format_value(chamfer)})")
                            lines.append(f"{indent});")
                        else:
                            lines.append(f"{indent}linear_extrude(height={height})")
                            for poly_line in polygon_code.split('\n'):
                                lines.append(f"{indent}    {poly_line}")
                    except:
                        lines.append(f"{indent}// Complex profile - manual adjustment needed")
                        lines.append(f"{indent}linear_extrude(height={height})")
                        lines.append(f"{indent}    polygon(points=[/* extracted points would go here */]);")
                else:
                    lines.append(f"{indent}// Complex profile - install profile_utils for auto-extraction")
                    lines.append(f"{indent}linear_extrude(height={height})")
                    lines.append(f"{indent}    polygon(points=[/* extracted points would go here */]);")

        return lines

    def generate_revolve_scad(self, feature_info: dict, feature_name: str) -> list:
        """Generate BOSL2 code for a revolution"""
        lines = []
        angle = self._format_value(feature_info['angle'])

        lines.append(f"// {feature_name}")
        if feature_info['angle'] == 360:
            lines.append("rotate_extrude()")
        else:
            lines.append(f"rotate_extrude(angle={angle})")
        lines.append("    polygon(points=[/* profile points */]);")

        return lines

    def process_timeline(self) -> list:
        """Process the design timeline and generate SCAD code for each feature.
        Uses a two-pass approach to associate fillets/chamfers with their parent shapes."""
        scad_code = []
        timeline = self.design.timeline

        # ============================================================
        # PASS 1: Collect all features and associate modifiers
        # ============================================================
        features_data = []  # List of (entity, name, info) tuples
        feature_to_bodies = {}  # Maps feature index to body tokens
        body_modifiers = {}  # Maps body token to {'rounding': value, 'chamfer': value}

        for i in range(timeline.count):
            item = timeline.item(i)
            entity = item.entity

            if entity is None:
                continue

            feature_name = item.name if hasattr(item, 'name') else f"feature_{i}"

            try:
                if isinstance(entity, adsk.fusion.ExtrudeFeature):
                    info = self.analyze_extrude_feature(entity)
                    features_data.append((entity, feature_name, info, 'extrude'))

                    # Track which bodies this feature creates/modifies
                    try:
                        for body in entity.bodies:
                            token = body.entityToken
                            feature_to_bodies[len(features_data) - 1] = token
                            if token not in body_modifiers:
                                body_modifiers[token] = {'rounding': 0, 'chamfer': 0}
                    except:
                        pass

                elif isinstance(entity, adsk.fusion.RevolveFeature):
                    info = self.analyze_revolve_feature(entity)
                    features_data.append((entity, feature_name, info, 'revolve'))

                    try:
                        for body in entity.bodies:
                            token = body.entityToken
                            feature_to_bodies[len(features_data) - 1] = token
                            if token not in body_modifiers:
                                body_modifiers[token] = {'rounding': 0, 'chamfer': 0}
                    except:
                        pass

                elif isinstance(entity, adsk.fusion.FilletFeature):
                    info = self.analyze_fillet_feature(entity)
                    # Associate fillet with affected bodies
                    for body_token in info['affected_bodies']:
                        if body_token in body_modifiers:
                            # Use the largest fillet radius if multiple
                            body_modifiers[body_token]['rounding'] = max(
                                body_modifiers[body_token]['rounding'],
                                info['radius']
                            )
                        else:
                            body_modifiers[body_token] = {'rounding': info['radius'], 'chamfer': 0}

                elif isinstance(entity, adsk.fusion.ChamferFeature):
                    info = self.analyze_chamfer_feature(entity)
                    # Associate chamfer with affected bodies
                    for body_token in info['affected_bodies']:
                        if body_token in body_modifiers:
                            body_modifiers[body_token]['chamfer'] = max(
                                body_modifiers[body_token]['chamfer'],
                                info['distance']
                            )
                        else:
                            body_modifiers[body_token] = {'rounding': 0, 'chamfer': info['distance']}

                elif isinstance(entity, adsk.fusion.Sketch):
                    # Sketches are processed as part of features that use them
                    pass

            except Exception as e:
                scad_code.append(f"// Error analyzing {feature_name}: {str(e)}")

        # ============================================================
        # PASS 2: Generate SCAD code with modifiers applied
        # ============================================================
        current_ops = {'union': [], 'difference': [], 'intersection': []}

        for idx, (entity, feature_name, info, feature_type) in enumerate(features_data):
            try:
                # Get modifiers for this feature's body
                body_token = feature_to_bodies.get(idx)
                modifiers = body_modifiers.get(body_token, {'rounding': 0, 'chamfer': 0})
                rounding = modifiers['rounding']
                chamfer = modifiers['chamfer']

                if feature_type == 'extrude':
                    code = self.generate_extrude_scad(info, feature_name,
                                                     rounding=rounding, chamfer=chamfer)

                    if info['operation'] == 'new' or info['operation'] == 'union':
                        current_ops['union'].extend(code)
                    elif info['operation'] == 'difference':
                        current_ops['difference'].extend(code)
                    elif info['operation'] == 'intersection':
                        current_ops['intersection'].extend(code)

                elif feature_type == 'revolve':
                    code = self.generate_revolve_scad(info, feature_name)
                    current_ops['union'].extend(code)

            except Exception as e:
                scad_code.append(f"// Error generating {feature_name}: {str(e)}")

        # ============================================================
        # Combine boolean operations
        # ============================================================
        if current_ops['difference']:
            scad_code.append("difference() {")
            if current_ops['union']:
                scad_code.append("    union() {")
                for line in current_ops['union']:
                    scad_code.append(f"        {line}")
                scad_code.append("    }")
            for line in current_ops['difference']:
                scad_code.append(f"    {line}")
            scad_code.append("}")
        elif current_ops['union']:
            if len(current_ops['union']) > 3:  # Multiple shapes
                scad_code.append("union() {")
                for line in current_ops['union']:
                    scad_code.append(f"    {line}")
                scad_code.append("}")
            else:
                scad_code.extend(current_ops['union'])

        return scad_code

    def export(self) -> str:
        """Generate complete OpenSCAD file content"""
        # Build the file
        all_lines = []

        # Header
        all_lines.extend(self.generate_header())

        # Extract and add parameters
        self.extract_parameters()
        all_lines.extend(self.generate_parameters_section())

        # Add geometry section header
        all_lines.extend([
            "// ============================================",
            "// Geometry (exported from Fusion 360 features)",
            "// ============================================",
            ""
        ])

        # Process timeline and generate geometry
        geometry_code = self.process_timeline()
        all_lines.extend(geometry_code)

        return '\n'.join(all_lines)

    def export_debug_json(self) -> dict:
        """Export detailed debug information from the Fusion 360 API"""
        debug_data = {
            'design_name': self.design.rootComponent.name,
            'parameters': {},
            'features': [],
            'bodies': [],
            'sketches': []
        }

        # Export parameters
        params = self.design.userParameters
        for i in range(params.count):
            param = params.item(i)
            debug_data['parameters'][param.name] = {
                'value': param.value,
                'value_mm': param.value * CM_TO_MM,
                'unit': param.unit,
                'expression': param.expression,
                'comment': param.comment
            }

        # Export timeline features
        timeline = self.design.timeline
        for i in range(timeline.count):
            item = timeline.item(i)
            entity = item.entity
            if entity is None:
                continue

            feature_data = {
                'index': i,
                'name': item.name if hasattr(item, 'name') else f'feature_{i}',
                'type': type(entity).__name__,
                'details': {}
            }

            try:
                if isinstance(entity, adsk.fusion.ExtrudeFeature):
                    # Get profile info
                    profiles = entity.profile
                    profile = profiles if isinstance(profiles, adsk.fusion.Profile) else (profiles.item(0) if profiles.count > 0 else None)

                    if profile:
                        sketch = profile.parentSketch
                        if sketch:
                            # Get sketch transform details
                            transform = sketch.transform
                            origin = sketch.origin

                            feature_data['details']['sketch_name'] = sketch.name
                            feature_data['details']['sketch_origin'] = {
                                'x': origin.x * CM_TO_MM,
                                'y': origin.y * CM_TO_MM,
                                'z': origin.z * CM_TO_MM
                            }

                            if transform:
                                # Get full transform matrix
                                cs = transform.getAsCoordinateSystem()
                                origin_pt, x_axis, y_axis, z_axis = cs

                                feature_data['details']['transform'] = {
                                    'origin': {'x': origin_pt.x, 'y': origin_pt.y, 'z': origin_pt.z},
                                    'x_axis': {'x': x_axis.x, 'y': x_axis.y, 'z': x_axis.z},
                                    'y_axis': {'x': y_axis.x, 'y': y_axis.y, 'z': y_axis.z},
                                    'z_axis': {'x': z_axis.x, 'y': z_axis.y, 'z': z_axis.z}
                                }

                            # Reference plane info
                            ref_plane = sketch.referencePlane
                            if ref_plane:
                                feature_data['details']['reference_plane'] = str(type(ref_plane).__name__)
                                if hasattr(ref_plane, 'geometry'):
                                    plane_geom = ref_plane.geometry
                                    if hasattr(plane_geom, 'normal'):
                                        n = plane_geom.normal
                                        feature_data['details']['plane_normal'] = {'x': n.x, 'y': n.y, 'z': n.z}
                                    if hasattr(plane_geom, 'origin'):
                                        o = plane_geom.origin
                                        feature_data['details']['plane_origin'] = {'x': o.x, 'y': o.y, 'z': o.z}

                    # Extrusion extent
                    extent_def = entity.extentOne
                    if isinstance(extent_def, adsk.fusion.DistanceExtentDefinition):
                        feature_data['details']['height_cm'] = extent_def.distance.value
                        feature_data['details']['height_mm'] = extent_def.distance.value * CM_TO_MM

                    # Start faces
                    try:
                        start_faces = entity.startFaces
                        if start_faces and start_faces.count > 0:
                            face = start_faces.item(0)
                            if hasattr(face, 'geometry') and hasattr(face.geometry, 'normal'):
                                n = face.geometry.normal
                                feature_data['details']['start_face_normal'] = {'x': n.x, 'y': n.y, 'z': n.z}
                    except:
                        pass

                    # End faces
                    try:
                        end_faces = entity.endFaces
                        if end_faces and end_faces.count > 0:
                            face = end_faces.item(0)
                            if hasattr(face, 'geometry') and hasattr(face.geometry, 'normal'):
                                n = face.geometry.normal
                                feature_data['details']['end_face_normal'] = {'x': n.x, 'y': n.y, 'z': n.z}
                    except:
                        pass

                    # Bodies created
                    try:
                        bodies = entity.bodies
                        body_list = []
                        for b in range(bodies.count):
                            body = bodies.item(b)
                            bbox = body.boundingBox
                            body_list.append({
                                'name': body.name,
                                'bbox_min': {'x': bbox.minPoint.x * CM_TO_MM, 'y': bbox.minPoint.y * CM_TO_MM, 'z': bbox.minPoint.z * CM_TO_MM},
                                'bbox_max': {'x': bbox.maxPoint.x * CM_TO_MM, 'y': bbox.maxPoint.y * CM_TO_MM, 'z': bbox.maxPoint.z * CM_TO_MM}
                            })
                        feature_data['details']['bodies'] = body_list
                    except:
                        pass

                    # Operation type
                    op_map = {
                        0: 'JoinFeatureOperation',
                        1: 'CutFeatureOperation',
                        2: 'IntersectFeatureOperation',
                        3: 'NewBodyFeatureOperation',
                        4: 'NewComponentFeatureOperation'
                    }
                    feature_data['details']['operation'] = op_map.get(entity.operation, str(entity.operation))

                elif isinstance(entity, adsk.fusion.Sketch):
                    feature_data['details']['profile_count'] = entity.profiles.count
                    feature_data['details']['curve_count'] = entity.sketchCurves.count

            except Exception as e:
                feature_data['error'] = str(e)

            debug_data['features'].append(feature_data)

        # Export bodies from root component
        try:
            bodies = self.design.rootComponent.bRepBodies
            for i in range(bodies.count):
                body = bodies.item(i)
                bbox = body.boundingBox
                debug_data['bodies'].append({
                    'name': body.name,
                    'bbox_min': {'x': bbox.minPoint.x * CM_TO_MM, 'y': bbox.minPoint.y * CM_TO_MM, 'z': bbox.minPoint.z * CM_TO_MM},
                    'bbox_max': {'x': bbox.maxPoint.x * CM_TO_MM, 'y': bbox.maxPoint.y * CM_TO_MM, 'z': bbox.maxPoint.z * CM_TO_MM}
                })
        except:
            pass

        return debug_data


# ============================================================
# Command and UI Setup
# ============================================================

# Command identifiers
COMMAND_ID = 'Fusion2SCAD_Export'
COMMAND_NAME = 'Export to OpenSCAD'
COMMAND_DESCRIPTION = 'Export parametric design to OpenSCAD with BOSL2 support'

# Keep track of event handlers to prevent garbage collection
handlers = []

# Keep track of UI elements for cleanup
toolbar_controls = []
command_definitions = []


class ExportCommandExecuteHandler(adsk.core.CommandEventHandler):
    """Handler for when the export command is executed"""

    def __init__(self):
        super().__init__()

    def notify(self, args):
        try:
            design = adsk.fusion.Design.cast(app.activeProduct)

            if not design:
                ui.messageBox('No active Fusion 360 design found.\nPlease open a design first.')
                return

            # Create file dialog
            file_dialog = ui.createFileDialog()
            file_dialog.isMultiSelectEnabled = False
            file_dialog.title = "Export to OpenSCAD (BOSL2)"
            file_dialog.filter = "OpenSCAD files (*.scad)"
            file_dialog.initialFilename = design.rootComponent.name + ".scad"

            dialog_result = file_dialog.showSave()

            if dialog_result != adsk.core.DialogResults.DialogOK:
                return

            filepath = file_dialog.filename

            # Export the design
            exporter = SCADExporter(design)
            scad_content = exporter.export()

            # Write SCAD file
            with open(filepath, 'w') as f:
                f.write(scad_content)

            # Also export debug JSON
            debug_filepath = filepath.replace('.scad', '_debug.json')
            debug_data = exporter.export_debug_json()
            with open(debug_filepath, 'w') as f:
                json.dump(debug_data, f, indent=2)

            # Show success message with summary
            param_count = len(exporter.parameters)
            feature_count = len(debug_data['features'])
            ui.messageBox(
                f'Export successful!\n\n'
                f'SCAD File: {filepath}\n'
                f'Debug JSON: {debug_filepath}\n\n'
                f'Parameters exported: {param_count}\n'
                f'Features exported: {feature_count}\n\n'
                f'Note: Make sure BOSL2 is installed in your OpenSCAD libraries folder.'
            )

        except:
            if ui:
                ui.messageBox(f'Export failed:\n{traceback.format_exc()}')


class ExportCommandCreatedHandler(adsk.core.CommandCreatedEventHandler):
    """Handler for when the command is created"""

    def __init__(self):
        super().__init__()

    def notify(self, args):
        try:
            cmd = args.command

            # Connect to the execute event
            on_execute = ExportCommandExecuteHandler()
            cmd.execute.add(on_execute)
            handlers.append(on_execute)

        except:
            if ui:
                ui.messageBox(f'Command created failed:\n{traceback.format_exc()}')


def run(context):
    """Main entry point for the Fusion 360 add-in - creates toolbar button"""
    try:
        global toolbar_controls, command_definitions

        # Get the Design workspace
        design_workspace = ui.workspaces.itemById('FusionSolidEnvironment')

        if not design_workspace:
            ui.messageBox('Could not find Design workspace')
            return

        # Get the Tools tab
        tools_tab = design_workspace.toolbarTabs.itemById('ToolsTab')
        if not tools_tab:
            # Try to find any available tab
            if design_workspace.toolbarTabs.count > 0:
                tools_tab = design_workspace.toolbarTabs.item(0)

        if not tools_tab:
            ui.messageBox('Could not find toolbar tab')
            return

        # Create a new panel or use existing one
        panel_id = 'Fusion2SCAD_Panel'
        panel = tools_tab.toolbarPanels.itemById(panel_id)

        if not panel:
            panel = tools_tab.toolbarPanels.add(panel_id, 'OpenSCAD Export')

        # Check if command already exists
        cmd_def = ui.commandDefinitions.itemById(COMMAND_ID)

        if not cmd_def:
            # Create command definition with icon
            # Icon should be in resources folder (16x16, 32x32 PNG)
            resources_folder = os.path.join(script_dir, 'resources')
            if not os.path.exists(resources_folder):
                resources_folder = ''

            cmd_def = ui.commandDefinitions.addButtonDefinition(
                COMMAND_ID,
                COMMAND_NAME,
                COMMAND_DESCRIPTION,
                resources_folder
            )
            command_definitions.append(cmd_def)

            # Set tooltip
            cmd_def.tooltip = COMMAND_DESCRIPTION

        # Connect to command created event
        on_command_created = ExportCommandCreatedHandler()
        cmd_def.commandCreated.add(on_command_created)
        handlers.append(on_command_created)

        # Add button to panel
        button_control = panel.controls.itemById(COMMAND_ID)
        if not button_control:
            button_control = panel.controls.addCommand(cmd_def)
            button_control.isPromoted = True  # Show in main toolbar
            button_control.isPromotedByDefault = True
            toolbar_controls.append(button_control)

        # Silent startup - no message box (uncomment below for first-time setup help)
        # ui.messageBox(
        #     'Fusion2SCAD loaded!\n\n'
        #     'Find the "Export to OpenSCAD" button in:\n'
        #     '• Tools tab → OpenSCAD Export panel\n\n'
        #     'Or search for "Export to OpenSCAD" in the search bar (S key)'
        # )

    except:
        if ui:
            ui.messageBox(f'Add-in initialization failed:\n{traceback.format_exc()}')


def stop(context):
    """Called when the add-in is stopped - cleanup UI elements"""
    try:
        global toolbar_controls, command_definitions, handlers

        # Remove toolbar controls
        for control in toolbar_controls:
            if control and control.isValid:
                control.deleteMe()
        toolbar_controls = []

        # Remove command definitions
        for cmd_def in command_definitions:
            if cmd_def and cmd_def.isValid:
                cmd_def.deleteMe()
        command_definitions = []

        # Clear handlers
        handlers = []

        # Try to remove the panel
        design_workspace = ui.workspaces.itemById('FusionSolidEnvironment')
        if design_workspace:
            tools_tab = design_workspace.toolbarTabs.itemById('ToolsTab')
            if tools_tab:
                panel = tools_tab.toolbarPanels.itemById('Fusion2SCAD_Panel')
                if panel and panel.isValid:
                    panel.deleteMe()

    except:
        if ui:
            ui.messageBox(f'Add-in cleanup failed:\n{traceback.format_exc()}')
