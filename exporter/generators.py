#Author: Fusion2SCAD
#Description: OpenSCAD/BOSL2 code generation functions

import sys
import os

from .utils import CM_TO_MM, format_value

# Try to import profile_utils
try:
    script_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
    if script_dir not in sys.path:
        sys.path.append(script_dir)
    from profile_utils import (
        extract_profile_polygon,
        format_polygon_scad,
        format_polygon_with_holes_scad
    )
    PROFILE_UTILS_AVAILABLE = True
except ImportError:
    PROFILE_UTILS_AVAILABLE = False


def generate_header() -> list:
    """Generate the OpenSCAD file header with BOSL2 include"""
    return [
        "// Generated by Fusion2SCAD",
        "// https://github.com/BelfrySCAD/BOSL2",
        "",
        "include <BOSL2/std.scad>",
        "include <BOSL2/rounding.scad>",
        "",
        "// Set default fragment count for smooth curves",
        "$fn = 32;",
        "",
        "// ============================================",
        "// Parameters (exported from Fusion 360)",
        "// ============================================",
        ""
    ]


def generate_parameters_section(parameters: dict) -> list:
    """Generate OpenSCAD variable declarations from Fusion parameters"""
    lines = []
    for orig_name, param_info in parameters.items():
        comment = f"  // {param_info['comment']}" if param_info['comment'] else ""
        lines.append(f"{param_info['name']} = {format_value(param_info['value'])};{comment}")
    if lines:
        lines.append("")
    return lines


def generate_transform_prefix(feature_info: dict, profile_center: tuple) -> tuple:
    """Generate multmatrix transform for proper 3D positioning using sketch transform.

    Returns:
        Tuple of (lines, indent_string)
    """
    lines = []
    indent = ""
    cx, cy = profile_center

    sketch_transform = feature_info.get('sketch_transform')

    if sketch_transform:
        ox, oy, oz = sketch_transform['origin']
        xx, xy, xz = sketch_transform['x_axis']
        yx, yy, yz = sketch_transform['y_axis']
        zx, zy, zz = sketch_transform['z_axis']

        ox, oy, oz = ox * CM_TO_MM, oy * CM_TO_MM, oz * CM_TO_MM

        tx = ox + xx * cx + yx * cy
        ty = oy + xy * cx + yy * cy
        tz = oz + xz * cx + yz * cy

        matrix = [
            [xx, yx, zx, tx],
            [xy, yy, zy, ty],
            [xz, yz, zz, tz],
            [0, 0, 0, 1]
        ]

        matrix_str = "[\n"
        for row in matrix:
            row_str = ", ".join(format_value(v) for v in row)
            matrix_str += f"        [{row_str}],\n"
        matrix_str = matrix_str.rstrip(",\n") + "\n    ]"

        lines.append(f"multmatrix({matrix_str})")
        indent = "    "
    else:
        plane_origin = feature_info.get('plane_origin', (0, 0, 0))
        rotation = feature_info.get('rotation')
        ox, oy, oz = plane_origin

        if rotation and rotation != (0, 0, 0):
            rx, ry, rz = rotation
            if ox != 0 or oy != 0 or oz != 0:
                lines.append(f"translate([{format_value(ox)}, {format_value(oy)}, {format_value(oz)}])")
                indent = "    "
            lines.append(f"{indent}rotate([{format_value(rx)}, {format_value(ry)}, {format_value(rz)}])")
            indent += "    "
            if cx != 0 or cy != 0:
                lines.append(f"{indent}translate([{format_value(cx)}, {format_value(cy)}, 0])")
                indent += "    "
        else:
            total_x = ox + cx
            total_y = oy + cy
            total_z = oz
            if total_x != 0 or total_y != 0 or total_z != 0:
                lines.append(f"translate([{format_value(total_x)}, {format_value(total_y)}, {format_value(total_z)}])")
                indent = "    "

    return lines, indent


def generate_extrude_scad(feature_info: dict, feature_name: str,
                          rounding: float = None, chamfer: float = None) -> list:
    """Generate BOSL2 code for an extrusion with optional rounding/chamfer"""
    lines = []
    height = format_value(feature_info['height'])

    for profile in feature_info['profiles']:
        lines.append(f"// {feature_name} (plane: {feature_info.get('sketch_plane', 'XY')})")

        if profile['is_circle']:
            radius = format_value(profile['radius'])
            cx, cy = profile['center']

            cyl_params = [f"h={height}", f"r={radius}"]
            if rounding and rounding > 0:
                cyl_params.append(f"rounding={format_value(rounding)}")
            if chamfer and chamfer > 0:
                cyl_params.append(f"chamfer={format_value(chamfer)}")
            cyl_params.append("anchor=BOTTOM")
            cyl_call = f"cyl({', '.join(cyl_params)});"

            transform_lines, indent = generate_transform_prefix(feature_info, (cx, cy))
            lines.extend(transform_lines)
            lines.append(f"{indent}{cyl_call}")

        elif profile.get('is_rounded_rect'):
            width = format_value(profile['bbox']['width'])
            depth = format_value(profile['bbox']['height'])
            sketch_rounding = format_value(profile['rounding'])
            cx, cy = profile['center']

            cuboid_params = [f"[{width}, {depth}, {height}]"]
            cuboid_params.append(f"rounding={sketch_rounding}")
            if rounding and rounding > 0:
                cuboid_params.append(f"edges=[\"Z\", TOP, BOTTOM]")
            else:
                cuboid_params.append(f"edges=\"Z\"")
            if chamfer and chamfer > 0:
                cuboid_params.append(f"chamfer={format_value(chamfer)}")
            cuboid_params.append("anchor=BOTTOM")
            cuboid_call = f"cuboid({', '.join(cuboid_params)});"

            transform_lines, indent = generate_transform_prefix(feature_info, (cx, cy))
            lines.extend(transform_lines)
            lines.append(f"{indent}{cuboid_call}")

        elif profile['is_rectangle']:
            width = format_value(profile['bbox']['width'])
            depth = format_value(profile['bbox']['height'])
            cx, cy = profile['center']

            cuboid_params = [f"[{width}, {depth}, {height}]"]
            if rounding and rounding > 0:
                cuboid_params.append(f"rounding={format_value(rounding)}")
            if chamfer and chamfer > 0:
                cuboid_params.append(f"chamfer={format_value(chamfer)}")
            cuboid_params.append("anchor=BOTTOM")
            cuboid_call = f"cuboid({', '.join(cuboid_params)});"

            transform_lines, indent = generate_transform_prefix(feature_info, (cx, cy))
            lines.extend(transform_lines)
            lines.append(f"{indent}{cuboid_call}")

        else:
            cx, cy = profile.get('center', (0, 0))
            transform_lines, indent = generate_transform_prefix(feature_info, (0, 0))
            lines.extend(transform_lines)

            if PROFILE_UTILS_AVAILABLE and 'profile_obj' in profile:
                try:
                    poly_data = extract_profile_polygon(profile['profile_obj'])
                    if poly_data['holes']:
                        polygon_code = format_polygon_with_holes_scad(
                            poly_data['outer'], poly_data['holes']
                        )
                    else:
                        polygon_code = format_polygon_scad(poly_data['outer'])

                    if rounding and rounding > 0:
                        lines.append(f"{indent}// Using BOSL2 offset_sweep for rounded extrusion")
                        lines.append(f"{indent}offset_sweep(")
                        for poly_line in polygon_code.split('\n'):
                            lines.append(f"{indent}    {poly_line},")
                        lines.append(f"{indent}    height={height},")
                        lines.append(f"{indent}    top=os_circle(r={format_value(rounding)}),")
                        lines.append(f"{indent}    bottom=os_circle(r={format_value(rounding)})")
                        lines.append(f"{indent});")
                    elif chamfer and chamfer > 0:
                        lines.append(f"{indent}// Using BOSL2 offset_sweep for chamfered extrusion")
                        lines.append(f"{indent}offset_sweep(")
                        for poly_line in polygon_code.split('\n'):
                            lines.append(f"{indent}    {poly_line},")
                        lines.append(f"{indent}    height={height},")
                        lines.append(f"{indent}    top=os_chamfer(height={format_value(chamfer)}),")
                        lines.append(f"{indent}    bottom=os_chamfer(height={format_value(chamfer)})")
                        lines.append(f"{indent});")
                    else:
                        lines.append(f"{indent}linear_extrude(height={height})")
                        poly_lines = polygon_code.split('\n')
                        for i, poly_line in enumerate(poly_lines):
                            if i == len(poly_lines) - 1:
                                # Add semicolon to last line
                                lines.append(f"{indent}    {poly_line};")
                            else:
                                lines.append(f"{indent}    {poly_line}")
                except:
                    lines.append(f"{indent}// Complex profile - manual adjustment needed")
                    lines.append(f"{indent}linear_extrude(height={height})")
                    lines.append(f"{indent}    polygon(points=[/* extracted points would go here */]);")
            else:
                lines.append(f"{indent}// Complex profile - install profile_utils for auto-extraction")
                lines.append(f"{indent}linear_extrude(height={height})")
                lines.append(f"{indent}    polygon(points=[/* extracted points would go here */]);")

    return lines


def generate_revolve_scad(feature_info: dict, feature_name: str) -> list:
    """Generate BOSL2 code for a revolution"""
    lines = []
    angle = format_value(feature_info['angle'])

    lines.append(f"// {feature_name}")
    if feature_info['angle'] == 360:
        lines.append("rotate_extrude()")
    else:
        lines.append(f"rotate_extrude(angle={angle})")
    lines.append("    polygon(points=[/* profile points */]);")

    return lines


def generate_hole_scad(feature_info: dict, feature_name: str) -> list:
    """Generate BOSL2 code for holes"""
    lines = []

    radius = format_value(feature_info['diameter'] / 2)
    depth = feature_info['depth']
    matrix = feature_info.get('matrix')

    lines.append(f"// {feature_name}")

    for x, y, z in feature_info['positions']:
        epsilon = 1.0
        total_h = format_value(depth + epsilon)

        lines.append(f"translate([{format_value(x)}, {format_value(y)}, {format_value(z)}])")

        if matrix:
            matrix_str = "[\n"
            for row in matrix:
                row_str = ", ".join(format_value(v) for v in row)
                matrix_str += f"        [{row_str}],\n"
            matrix_str = matrix_str.rstrip(",\n") + "\n    ]"
            lines.append(f"    multmatrix({matrix_str})")

        lines.append(f"    translate([0, 0, -{epsilon}])")
        lines.append(f"    cyl(h={total_h}, r={radius}, anchor=BOTTOM);")

    return lines
